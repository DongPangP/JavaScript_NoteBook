# 执行上下文与作用域

变量或函数的上下文决定了它们可以访问哪些数据。

每个上下文都有一个关联的 变量对象 ，而这个上下文中定义的所有变量和函数都存在于这个对象上。

### 执行上下文

在浏览器中，全局上下文（最外层的上下文）=> window 对象。

- 所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。
- 使用 let 和 const  的顶级声明不会定义在全局上下文中，但是在作用域链的解析上效果一样。
- 上下文会在其所有代码执行完毕后被销毁，包括在上面的所有变量和函数。
- 全局上下文会在应用程序推出时才会被销毁，比如关闭网页和退出浏览器。

### 函数上下文

每个函数的调用都有自己的上下文。

- 当代码执行流进入函数时，函数的上下文被推到一个上下文栈中。
- 在函数执行完之后，上下文会弹出该函数上下文，将控制权还给之前的执行上下文。

ECMAScript 程序的执行流就是通过这个上下文栈进行控制。

### 作用域链

上下文的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。

作用域链决定了各级上下文中代码的访问变量和函数时的顺序。

代码正在执行的上下文变量对象始终位于作用域链的最前端，如果上下文是函数，则其活动对象用作变量对象。

活动对象最初只有一个定义变量：arguments (<span style="color:yellow">全局上下文中没有这个变量</span>)

作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。

<span style="color:skyblue">代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错）</span>

```
var color = "blue";

function changeColor() {
	if(color === "blue"){
		color = "red";
	}else{
		color = "blue";
	}
}

changeColor();
```

函数 changeColor() 的作用域链包含两个对象，一个是它自己的变量对象（就是定义 arguments 对象的那个），另一个是全局上下文的变量对象。

```
var color = "blue";

function changeColor(){
	let anotherColor = "red";
	
	function swapColors(){
		let tempColor = anotherColor;
		anotherColor = color;
		color = tempColor;
		
		// 这里可以访问 color、anotherColor、tempColor
	}
	// 这里可以访问 color 和 anotherColor
	swapColors();
}
// 只能访问color
changeColor();
```











